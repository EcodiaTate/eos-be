"""
EcodiaOS -- Simula Resolution Types (Stage 5E)

Types for autonomous issue resolution with progressive autonomy.
Based on the LogicStar pattern (investigate → reproduce → fix → validate → abstain)
with strict abstention policy: if confidence < threshold, return diagnostic
context but never apply a partial fix.

Autonomy levels (ordered by risk):
  LINT          → auto-fix lint errors (ruff --fix)
  DEPENDENCY    → auto-resolve dependency conflicts
  TEST_FIX      → semi-auto fix test failures (requires confidence > threshold)
  LOGIC_BUG     → supervised fix (always requires human approval)
"""

from __future__ import annotations

import enum
from datetime import datetime

from pydantic import Field

from ecodiaos.primitives.common import EOSBaseModel, utc_now


# ── Enums ────────────────────────────────────────────────────────────────────


class AutonomyLevel(str, enum.Enum):
    """Progressive autonomy levels — ordered by risk and required confidence."""

    LINT = "lint"
    DEPENDENCY = "dependency"
    TEST_FIX = "test_fix"
    LOGIC_BUG = "logic_bug"


class IssueKind(str, enum.Enum):
    """Classification of detected issues."""

    LINT_ERROR = "lint_error"
    DEPENDENCY_CONFLICT = "dependency_conflict"
    TEST_FAILURE = "test_failure"
    LOGIC_BUG = "logic_bug"
    PERF_REGRESSION = "perf_regression"
    SECURITY_VULN = "security_vuln"
    DEGRADATION = "degradation"


class IssueSource(str, enum.Enum):
    """Where the issue was detected."""

    HEALTH_CHECK = "health_check"
    CI_CD = "ci_cd"
    MONITORING = "monitoring"
    MANUAL = "manual"


class ResolutionStatus(str, enum.Enum):
    """Terminal outcome of an issue resolution attempt."""

    RESOLVED = "resolved"
    ABSTAINED = "abstained"
    FAILED = "failed"
    TIMEOUT = "timeout"
    ESCALATED = "escalated"


# ── Issue models ────────────────────────────────────────────────────────────


class DetectedIssue(EOSBaseModel):
    """An issue detected by monitors, health check, CI/CD, or manual submission."""

    issue_id: str = ""
    kind: IssueKind = IssueKind.LINT_ERROR
    source: IssueSource = IssueSource.HEALTH_CHECK
    title: str = ""
    description: str = ""
    severity: str = ""  # "low"|"medium"|"high"|"critical"
    file_path: str = ""
    line_number: int = 0
    stack_trace: str = ""
    proposal_id: str = ""  # related evolution proposal (if applicable)
    detected_at: datetime = Field(default_factory=utc_now)


class ResolutionAttempt(EOSBaseModel):
    """One attempt to resolve an issue (within the LogicStar pipeline)."""

    attempt_number: int = 0
    phase: str = ""  # "investigate"|"reproduce"|"fix"|"validate"|"abstain"
    autonomy_level: AutonomyLevel = AutonomyLevel.LINT
    confidence: float = 0.0
    fix_description: str = ""
    files_modified: list[str] = Field(default_factory=list)
    tests_passed: bool = False
    lint_clean: bool = False
    cost_usd: float = 0.0
    duration_ms: int = 0
    error: str = ""


class ResolutionResult(EOSBaseModel):
    """Final outcome of an issue resolution pipeline run."""

    status: ResolutionStatus = ResolutionStatus.ABSTAINED
    issue: DetectedIssue | None = None
    autonomy_level_used: AutonomyLevel = AutonomyLevel.LINT
    attempts: list[ResolutionAttempt] = Field(default_factory=list)
    total_attempts: int = 0
    files_modified: list[str] = Field(default_factory=list)
    confidence: float = 0.0
    abstention_reason: str = ""  # populated when status == ABSTAINED
    escalation_context: str = ""  # populated when status == ESCALATED
    diagnostic_summary: str = ""  # always populated, even on abstention
    total_cost_usd: float = 0.0
    total_duration_ms: int = 0


# ── Monitoring models ───────────────────────────────────────────────────────


class MonitoringAlert(EOSBaseModel):
    """Alert generated by one of the Stage 5E monitors."""

    alert_id: str = ""
    monitor_type: str = ""  # "perf_regression"|"security_vuln"|"degradation"
    issue_kind: IssueKind = IssueKind.PERF_REGRESSION
    title: str = ""
    description: str = ""
    severity: str = "medium"
    metric_name: str = ""
    metric_value: float = 0.0
    threshold: float = 0.0
    file_path: str = ""
    detected_at: datetime = Field(default_factory=utc_now)


# ── Constants ───────────────────────────────────────────────────────────────


AUTONOMY_LEVEL_THRESHOLDS: dict[AutonomyLevel, float] = {
    AutonomyLevel.LINT: 0.5,         # low bar — lint fixes are safe
    AutonomyLevel.DEPENDENCY: 0.6,   # moderate — dep resolution is well-understood
    AutonomyLevel.TEST_FIX: 0.8,     # high bar — test fixes can mask bugs
    AutonomyLevel.LOGIC_BUG: 1.0,    # effectively infinite — always requires human
}

ISSUE_KIND_TO_AUTONOMY: dict[IssueKind, AutonomyLevel] = {
    IssueKind.LINT_ERROR: AutonomyLevel.LINT,
    IssueKind.DEPENDENCY_CONFLICT: AutonomyLevel.DEPENDENCY,
    IssueKind.TEST_FAILURE: AutonomyLevel.TEST_FIX,
    IssueKind.LOGIC_BUG: AutonomyLevel.LOGIC_BUG,
    IssueKind.PERF_REGRESSION: AutonomyLevel.TEST_FIX,
    IssueKind.SECURITY_VULN: AutonomyLevel.LOGIC_BUG,
    IssueKind.DEGRADATION: AutonomyLevel.TEST_FIX,
}
