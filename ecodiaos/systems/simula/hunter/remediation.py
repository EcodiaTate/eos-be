"""
EcodiaOS — Hunter Autonomous Remediation (Phase 6)

Bridges Hunter vulnerability discoveries into the existing RepairAgent
(Stage 5B) pipeline, then re-verifies patches via Z3 to confirm the
vulnerability is eliminated.

The key loop:
  1. Translate VulnerabilityReport → synthetic EvolutionProposal + broken_files
  2. Call RepairAgent.repair() to generate a fix via its FSM pipeline
  3. Re-run VulnerabilityProver.prove_vulnerability() on patched code
  4. If UNSAT → patch verified (vulnerability eliminated)
  5. If SAT  → retry with refined context from the failed verification

This reuses the existing repair pipeline entirely — no new verification
logic needed. The only new logic is the translation layer between Hunter's
VulnerabilityReport and RepairAgent's EvolutionProposal + broken_files
contract, and the Z3 re-verification loop.

Iron Rules:
  - Hunter NEVER writes to EOS source files; patches target workspace only
  - All remediation events logged via structlog for analytics
  - Cost budget is strictly enforced per-vulnerability
"""

from __future__ import annotations

import difflib
import time
from typing import TYPE_CHECKING

import structlog

from ecodiaos.primitives.common import new_id, utc_now
from ecodiaos.systems.simula.hunter.types import (
    RemediationAttempt,
    RemediationResult,
    RemediationStatus,
    VulnerabilityReport,
)
from ecodiaos.systems.simula.types import (
    ChangeCategory,
    ChangeSpec,
    EvolutionProposal,
)

if TYPE_CHECKING:
    from ecodiaos.systems.simula.agents.repair_agent import RepairAgent
    from ecodiaos.systems.simula.hunter.prover import VulnerabilityProver
    from ecodiaos.systems.simula.hunter.workspace import TargetWorkspace

logger = structlog.get_logger().bind(system="simula.hunter.remediation")


# ── System prompt for security-aware fix generation ──────────────────────────

_SECURITY_FIX_CONTEXT = """Security vulnerability context for repair:

Vulnerability class: {vulnerability_class}
Severity: {severity}
Attack goal: {attack_goal}

Z3 counterexample (proof the vulnerability exists):
{z3_counterexample}

The fix must eliminate this specific vulnerability. Common remediation
patterns:
- broken_authentication → add authentication check before resource access
- broken_access_control → enforce authorization/ownership check
- injection/sql_injection → use parameterized queries, sanitize input
- privilege_escalation → enforce role-based access check
- reentrancy → add reentrancy guard / checks-effects-interactions pattern
- race_condition → add locking / atomic operations
- unvalidated_redirect → validate redirect target against allowlist
- path_traversal → normalize path, reject directory traversal
- command_injection → use subprocess with list args, never shell=True
"""


class HunterRepairOrchestrator:
    """
    Orchestrates autonomous remediation of discovered vulnerabilities.

    Bridges Hunter's VulnerabilityReport into the RepairAgent pipeline,
    then re-verifies via Z3 to confirm vulnerability elimination.
    """

    def __init__(
        self,
        repair_agent: RepairAgent,
        prover: VulnerabilityProver,
        workspace: TargetWorkspace,
        *,
        max_retries: int = 2,
        cost_budget_usd: float = 0.15,
        timeout_s: float = 300.0,
    ) -> None:
        """
        Args:
            repair_agent: The Stage 5B RepairAgent for fix generation.
            prover: The VulnerabilityProver for re-verification.
            workspace: The target workspace containing the vulnerable code.
            max_retries: Max remediation attempts per vulnerability.
            cost_budget_usd: Hard cost cap for remediation of one vulnerability.
            timeout_s: Total timeout in seconds for the full remediation.
        """
        self._repair_agent = repair_agent
        self._prover = prover
        self._workspace = workspace
        self._max_retries = max_retries
        self._cost_budget = cost_budget_usd
        self._timeout_s = timeout_s

    # ── Public API ──────────────────────────────────────────────────────────

    @property
    def workspace(self) -> TargetWorkspace:
        """The current target workspace for remediation."""
        return self._workspace

    def set_workspace(self, workspace: TargetWorkspace) -> None:
        """
        Replace the workspace for the next remediation run.

        HunterService calls this before each hunt so patches target
        the correct codebase rather than a stale placeholder.
        """
        self._workspace = workspace

    async def generate_patch(
        self,
        vulnerability_report: VulnerabilityReport,
    ) -> RemediationResult:
        """
        Generate and verify a patch for a proven vulnerability.

        Pipeline:
          1. Build synthetic EvolutionProposal from the VulnerabilityReport
          2. Extract vulnerable source code from the workspace
          3. Call RepairAgent.repair() with security-enriched context
          4. If repair succeeds, re-run VulnerabilityProver to verify
          5. Return RemediationResult with patch diff

        Args:
            vulnerability_report: A proven VulnerabilityReport from the Hunter prover.

        Returns:
            RemediationResult with the patch diff and verification status.
        """
        start = time.monotonic()
        vuln = vulnerability_report
        log = logger.bind(
            vulnerability_id=vuln.id,
            vulnerability_class=vuln.vulnerability_class,
            severity=vuln.severity,
            file_path=vuln.attack_surface.file_path,
        )
        log.info("remediation_started")

        attempts: list[RemediationAttempt] = []

        # Read the vulnerable source from workspace
        vulnerable_code, read_error = self._read_vulnerable_code(vuln)
        if read_error:
            log.warning("remediation_code_read_failed", error=read_error)
            return RemediationResult(
                vulnerability_id=vuln.id,
                status=RemediationStatus.FAILED,
                attempts=[RemediationAttempt(
                    attempt_number=0,
                    error=read_error,
                )],
                total_attempts=1,
                total_duration_ms=int((time.monotonic() - start) * 1000),
            )

        # Build synthetic EvolutionProposal for RepairAgent
        proposal = self._build_synthetic_proposal(vuln)

        # Build security-enriched error context for the RepairAgent
        security_context = _SECURITY_FIX_CONTEXT.format(
            vulnerability_class=vuln.vulnerability_class,
            severity=vuln.severity,
            attack_goal=vuln.attack_goal,
            z3_counterexample=vuln.z3_counterexample,
        )

        # Retry loop
        for attempt_num in range(self._max_retries):
            # Check timeout
            elapsed = time.monotonic() - start
            if elapsed > self._timeout_s:
                log.warning("remediation_timeout", elapsed_s=elapsed)
                return self._build_result(
                    vuln.id, RemediationStatus.TIMEOUT, attempts, start,
                )

            attempt_start = time.monotonic()
            attempt = RemediationAttempt(attempt_number=attempt_num)

            try:
                # Step 1: Call RepairAgent
                log.info("repair_attempt_starting", attempt=attempt_num)
                broken_files = {vuln.attack_surface.file_path: vulnerable_code}

                repair_result = await self._repair_agent.repair(
                    proposal=proposal,
                    broken_files=broken_files,
                    test_output=security_context,
                )

                attempt.repair_status = repair_result.status.value
                attempt.cost_usd = repair_result.total_cost_usd

                from ecodiaos.systems.simula.verification.types import RepairStatus

                if repair_result.status != RepairStatus.REPAIRED:
                    attempt.error = (
                        f"RepairAgent returned {repair_result.status}: "
                        f"{repair_result.fix_summary or repair_result.diagnosis_summary}"
                    )
                    attempt.duration_ms = int(
                        (time.monotonic() - attempt_start) * 1000
                    )
                    attempts.append(attempt)
                    log.info(
                        "repair_attempt_no_fix",
                        attempt=attempt_num,
                        status=repair_result.status,
                    )
                    continue

                # Step 2: Read patched code from disk
                patched_code = self._read_patched_file(vuln)
                if not patched_code:
                    attempt.error = "RepairAgent reported success but patched file not found"
                    attempt.duration_ms = int(
                        (time.monotonic() - attempt_start) * 1000
                    )
                    attempts.append(attempt)
                    continue

                attempt.patched_code = patched_code

                # Step 3: Generate unified diff
                attempt.patch_diff = self._generate_diff(
                    vuln.attack_surface.file_path,
                    vulnerable_code,
                    patched_code,
                )

                # Step 4: Re-verify via VulnerabilityProver
                log.info("reverification_starting", attempt=attempt_num)

                # Build a temporary AttackSurface with the patched code
                patched_surface = vuln.attack_surface.model_copy(
                    update={"context_code": patched_code}
                )

                reverification = await self._prover.prove_vulnerability(
                    surface=patched_surface,
                    attack_goal=vuln.attack_goal,
                    target_url=vuln.target_url,
                )

                if reverification is None:
                    # UNSAT — vulnerability eliminated
                    attempt.verification_result = "UNSAT"
                    attempt.vulnerability_eliminated = True
                    attempt.duration_ms = int(
                        (time.monotonic() - attempt_start) * 1000
                    )
                    attempts.append(attempt)

                    log.info(
                        "remediation_verified",
                        attempt=attempt_num,
                        cost=f"${attempt.cost_usd:.4f}",
                        event="patch_generated",
                    )

                    return self._build_result(
                        vuln.id,
                        RemediationStatus.PATCHED,
                        attempts,
                        start,
                        successful_attempt=attempt_num,
                        final_diff=attempt.patch_diff,
                        final_code=patched_code,
                    )

                # SAT — vulnerability still present after patch
                attempt.verification_result = "SAT"
                attempt.error = (
                    "Patch did not eliminate vulnerability. "
                    f"Z3 still found: {reverification.z3_counterexample[:200]}"
                )
                attempt.duration_ms = int(
                    (time.monotonic() - attempt_start) * 1000
                )
                attempts.append(attempt)

                log.info(
                    "reverification_failed",
                    attempt=attempt_num,
                    counterexample=reverification.z3_counterexample[:100],
                )

                # Enrich context for next attempt with the failed verification
                security_context += (
                    f"\n\nPrevious patch attempt {attempt_num} was insufficient. "
                    f"Z3 re-verification still found the vulnerability exploitable "
                    f"with counterexample: {reverification.z3_counterexample[:300]}\n"
                    f"The patch must be more thorough."
                )

                # Restore original code for next attempt
                self._restore_original(vuln, vulnerable_code)

            except Exception as exc:
                attempt.error = f"Remediation error: {exc}"
                attempt.duration_ms = int(
                    (time.monotonic() - attempt_start) * 1000
                )
                attempts.append(attempt)
                log.exception("remediation_attempt_error", attempt=attempt_num)

                # Restore original code on error
                self._restore_original(vuln, vulnerable_code)

        # All retries exhausted
        log.warning(
            "remediation_exhausted",
            total_attempts=len(attempts),
        )
        return self._build_result(
            vuln.id, RemediationStatus.FAILED, attempts, start,
        )

    async def generate_patches_batch(
        self,
        vulnerability_reports: list[VulnerabilityReport],
    ) -> dict[str, RemediationResult]:
        """
        Generate patches for multiple vulnerabilities sequentially.

        Processes vulnerabilities in severity order (CRITICAL first).

        Args:
            vulnerability_reports: List of proven VulnerabilityReports.

        Returns:
            Dict mapping vulnerability ID → RemediationResult.
        """
        # Sort by severity: CRITICAL > HIGH > MEDIUM > LOW
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        sorted_reports = sorted(
            vulnerability_reports,
            key=lambda r: severity_order.get(r.severity.value, 99),
        )

        results: dict[str, RemediationResult] = {}

        for report in sorted_reports:
            logger.info(
                "batch_remediation_next",
                vulnerability_id=report.id,
                severity=report.severity,
                vulnerability_class=report.vulnerability_class,
            )
            result = await self.generate_patch(report)
            results[report.id] = result

            logger.info(
                "batch_remediation_done",
                vulnerability_id=report.id,
                status=result.status,
                event="patch_generated" if result.status == RemediationStatus.PATCHED else "patch_failed",
            )

        patched = sum(1 for r in results.values() if r.status == RemediationStatus.PATCHED)
        logger.info(
            "batch_remediation_complete",
            total=len(results),
            patched=patched,
            failed=len(results) - patched,
        )

        return results

    # ── Private helpers ─────────────────────────────────────────────────────

    def _build_synthetic_proposal(
        self, vuln: VulnerabilityReport
    ) -> EvolutionProposal:
        """
        Build a synthetic EvolutionProposal from a VulnerabilityReport.

        The RepairAgent expects an EvolutionProposal + broken_files.
        We translate the security vulnerability context into the proposal
        format so RepairAgent can leverage its full FSM pipeline.
        """
        return EvolutionProposal(
            id=new_id(),
            source="hunter",
            category=ChangeCategory.ADD_SYSTEM_CAPABILITY,
            description=(
                f"Security fix: {vuln.vulnerability_class.value} "
                f"vulnerability ({vuln.severity.value}) in "
                f"{vuln.attack_surface.file_path} — {vuln.attack_goal}"
            ),
            change_spec=ChangeSpec(
                capability_description=(
                    f"Remediate {vuln.vulnerability_class.value} vulnerability. "
                    f"Attack surface: {vuln.attack_surface.entry_point} "
                    f"({vuln.attack_surface.surface_type.value}). "
                    f"Z3-proven counterexample: {vuln.z3_counterexample[:500]}"
                ),
                additional_context=(
                    f"Attack goal: {vuln.attack_goal}\n"
                    f"Severity: {vuln.severity.value}\n"
                    f"File: {vuln.attack_surface.file_path}\n"
                    f"Entry point: {vuln.attack_surface.entry_point}"
                ),
                affected_systems=["hunter"],
            ),
            expected_benefit=f"Eliminate {vuln.severity.value}-severity {vuln.vulnerability_class.value} vulnerability",
            risk_assessment="Low risk — targeted security patch for proven vulnerability",
            created_at=utc_now(),
        )

    def _read_vulnerable_code(
        self, vuln: VulnerabilityReport
    ) -> tuple[str, str]:
        """
        Read the vulnerable source file from the workspace.

        Returns:
            (source_code, error_message). Error is empty on success.
        """
        file_path = self._workspace.root / vuln.attack_surface.file_path
        try:
            if not file_path.exists():
                return "", f"File not found: {vuln.attack_surface.file_path}"
            content = file_path.read_text(encoding="utf-8")
            if not content.strip():
                return "", f"File is empty: {vuln.attack_surface.file_path}"
            return content, ""
        except OSError as exc:
            return "", f"Failed to read {vuln.attack_surface.file_path}: {exc}"

    def _read_patched_file(self, vuln: VulnerabilityReport) -> str:
        """Read the patched file after RepairAgent has written it."""
        file_path = self._workspace.root / vuln.attack_surface.file_path
        try:
            if file_path.exists():
                return file_path.read_text(encoding="utf-8")
        except OSError:
            pass
        return ""

    def _restore_original(
        self, vuln: VulnerabilityReport, original_code: str
    ) -> None:
        """Restore the original vulnerable code after a failed patch attempt."""
        file_path = self._workspace.root / vuln.attack_surface.file_path
        try:
            file_path.write_text(original_code, encoding="utf-8")
        except OSError as exc:
            logger.warning(
                "restore_original_failed",
                file_path=str(file_path),
                error=str(exc),
            )

    @staticmethod
    def _generate_diff(
        file_path: str, original: str, patched: str
    ) -> str:
        """Generate a unified diff between original and patched code."""
        original_lines = original.splitlines(keepends=True)
        patched_lines = patched.splitlines(keepends=True)
        diff_lines = difflib.unified_diff(
            original_lines,
            patched_lines,
            fromfile=f"a/{file_path}",
            tofile=f"b/{file_path}",
            lineterm="",
        )
        return "".join(diff_lines)

    @staticmethod
    def _build_result(
        vulnerability_id: str,
        status: RemediationStatus,
        attempts: list[RemediationAttempt],
        start: float,
        *,
        successful_attempt: int | None = None,
        final_diff: str = "",
        final_code: str = "",
    ) -> RemediationResult:
        """Build the aggregate RemediationResult."""
        total_cost = sum(a.cost_usd for a in attempts)
        total_duration = int((time.monotonic() - start) * 1000)

        return RemediationResult(
            vulnerability_id=vulnerability_id,
            status=status,
            attempts=attempts,
            total_attempts=len(attempts),
            successful_attempt=successful_attempt,
            final_patch_diff=final_diff,
            final_patched_code=final_code,
            total_cost_usd=total_cost,
            total_duration_ms=total_duration,
            remediated_at=utc_now(),
        )
