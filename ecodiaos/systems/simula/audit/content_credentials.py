"""
EcodiaOS -- Simula Content Credentials Manager (Stage 6A.2)

C2PA content credentials for code provenance.

Every file generated by Simula's code agent carries an authorship proof:
  - SHA-256 content hash
  - Ed25519 digital signature
  - C2PA-style manifest with issuer, timestamp, algorithm metadata

This enables verifiable provenance chains for regulatory compliance
(SOX, HIPAA, CMMC) — any auditor can verify that a file was generated
by Simula at a specific time and has not been modified since.
"""

from __future__ import annotations

import hashlib
import json
import time
from pathlib import Path
from typing import TYPE_CHECKING

import structlog

from ecodiaos.primitives.common import new_id, utc_now
from ecodiaos.systems.simula.verification.types import (
    ContentCredential,
    ContentCredentialResult,
    ContentCredentialStatus,
)

if TYPE_CHECKING:
    from cryptography.hazmat.primitives.asymmetric.ed25519 import (
        Ed25519PrivateKey,
        Ed25519PublicKey,
    )

logger = structlog.get_logger().bind(system="simula.audit.content_credentials")


class ContentCredentialManager:
    """Signs and verifies C2PA content credentials for generated code files."""

    def __init__(
        self,
        *,
        signing_key_path: str = "",
        issuer_name: str = "EcodiaOS Simula",
    ) -> None:
        self._issuer = issuer_name
        self._private_key: Ed25519PrivateKey | None = None
        self._public_key: Ed25519PublicKey | None = None

        if signing_key_path:
            self._load_signing_key(signing_key_path)

    # ── Public API ──────────────────────────────────────────────────────────

    async def sign_files(
        self,
        files: list[str],
        codebase_root: Path,
    ) -> ContentCredentialResult:
        """
        Sign a batch of generated files with C2PA content credentials.

        For each file:
        1. Compute SHA-256 content hash
        2. Sign the hash with Ed25519 private key
        3. Build a C2PA manifest JSON with provenance metadata
        """
        start = time.monotonic()
        credentials: list[ContentCredential] = []
        unsigned: list[str] = []

        for file_path in files:
            full_path = codebase_root / file_path
            if not full_path.exists():
                unsigned.append(file_path)
                continue

            try:
                content = full_path.read_bytes()
                content_hash = hashlib.sha256(content).hexdigest()

                signature = ""
                if self._private_key is not None:
                    sig_bytes = self._private_key.sign(content_hash.encode("utf-8"))
                    signature = sig_bytes.hex()

                now = utc_now()
                manifest = {
                    "claim_generator": "EcodiaOS Simula/1.0",
                    "claim_generator_info": [
                        {"name": "EcodiaOS", "version": "1.0"},
                    ],
                    "title": file_path,
                    "dc:format": "application/octet-stream",
                    "instance_id": f"urn:uuid:{new_id()}",
                    "assertions": [
                        {
                            "label": "c2pa.hash.sha256",
                            "data": {"hash": content_hash, "algorithm": "SHA-256"},
                        },
                        {
                            "label": "c2pa.actions",
                            "data": {
                                "actions": [
                                    {
                                        "action": "c2pa.created",
                                        "when": now.isoformat(),
                                        "softwareAgent": "EcodiaOS Simula Code Agent",
                                    },
                                ],
                            },
                        },
                    ],
                    "signature_info": {
                        "issuer": self._issuer,
                        "algorithm": "Ed25519",
                        "time": now.isoformat(),
                    },
                }

                credential = ContentCredential(
                    file_path=file_path,
                    content_hash=content_hash,
                    issuer=self._issuer,
                    signature=signature,
                    algorithm="Ed25519",
                    c2pa_manifest_json=json.dumps(manifest),
                    created_at=now,
                )
                credentials.append(credential)

            except Exception as exc:
                logger.warning(
                    "file_signing_failed",
                    file_path=file_path,
                    error=str(exc),
                )
                unsigned.append(file_path)

        status = ContentCredentialStatus.SIGNED if credentials else ContentCredentialStatus.UNSIGNED
        elapsed_ms = int((time.monotonic() - start) * 1000)

        logger.info(
            "files_signed",
            signed=len(credentials),
            unsigned=len(unsigned),
            duration_ms=elapsed_ms,
        )

        return ContentCredentialResult(
            status=status,
            credentials=credentials,
            unsigned_files=unsigned,
            verified_count=0,
            invalid_count=0,
            duration_ms=elapsed_ms,
        )

    async def verify_file(
        self,
        file_path: str,
        credential: ContentCredential,
        codebase_root: Path,
    ) -> bool:
        """Verify a single file's content credential."""
        full_path = codebase_root / file_path
        if not full_path.exists():
            return False

        content = full_path.read_bytes()
        content_hash = hashlib.sha256(content).hexdigest()

        # Check content hash matches
        if content_hash != credential.content_hash:
            logger.warning(
                "content_hash_mismatch",
                file_path=file_path,
                expected=credential.content_hash[:16],
                actual=content_hash[:16],
            )
            return False

        # Verify signature if we have a public key
        if self._public_key is not None and credential.signature:
            try:
                sig_bytes = bytes.fromhex(credential.signature)
                self._public_key.verify(sig_bytes, content_hash.encode("utf-8"))
            except Exception:
                logger.warning("signature_verification_failed", file_path=file_path)
                return False

        return True

    async def verify_batch(
        self,
        credentials: list[ContentCredential],
        codebase_root: Path,
    ) -> ContentCredentialResult:
        """Verify a batch of content credentials."""
        start = time.monotonic()
        verified = 0
        invalid = 0

        for cred in credentials:
            if await self.verify_file(cred.file_path, cred, codebase_root):
                verified += 1
            else:
                invalid += 1

        status = (
            ContentCredentialStatus.VERIFIED
            if invalid == 0 and verified > 0
            else ContentCredentialStatus.INVALID
            if invalid > 0
            else ContentCredentialStatus.UNSIGNED
        )

        elapsed_ms = int((time.monotonic() - start) * 1000)
        return ContentCredentialResult(
            status=status,
            credentials=credentials,
            verified_count=verified,
            invalid_count=invalid,
            duration_ms=elapsed_ms,
        )

    # ── Private helpers ─────────────────────────────────────────────────────

    def _load_signing_key(self, key_path: str) -> None:
        """Load Ed25519 private key from PEM file."""
        try:
            from cryptography.hazmat.primitives.serialization import (
                load_pem_private_key,
            )

            path = Path(key_path)
            if not path.exists():
                logger.warning("signing_key_not_found", path=key_path)
                return

            key_data = path.read_bytes()
            private_key = load_pem_private_key(key_data, password=None)

            from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey

            if isinstance(private_key, Ed25519PrivateKey):
                self._private_key = private_key
                self._public_key = private_key.public_key()
                logger.info("signing_key_loaded", path=key_path)
            else:
                logger.warning("signing_key_not_ed25519", key_type=type(private_key).__name__)

        except Exception as exc:
            logger.warning("signing_key_load_failed", error=str(exc))
