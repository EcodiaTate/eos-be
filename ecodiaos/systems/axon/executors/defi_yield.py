"""
EcodiaOS -- Axon DeFi Yield Executor (Phase 16c: Resting Metabolism)

Deploys idle capital into yield-bearing DeFi protocols on Base L2 during
consolidation cycles -- the organism's resting metabolism.

DeFiYieldExecutor  -- (Level 3) deposit/withdraw USDC into Aave / Morpho via
                      the organism's CDP-managed wallet.

When EcodiaOS has idle capital above the gas-efficiency floor, this executor
supplies it to lending protocols to earn yield.  When capital is needed, it
withdraws.  This prevents cash drag during consolidation.

Safety constraints:
  - Required autonomy: SOVEREIGN (3) -- deploys real capital on-chain
  - Rate limit: 4 operations per hour -- DeFi interactions are expensive
  - MIN_DEPLOYABLE_BALANCE: $20.00 -- gas-efficiency floor; below this the
    cost of the tx outweighs the yield earned
  - YIELD_FLOOR_APY: 0.02 (2%) -- minimum acceptable APY; deposits abort
    if the protocol's reported rate is below this floor
  - Reversible: False -- on-chain interactions are irreversible once broadcast
  - WalletClient injected at construction; never resolved from globals
  - Only USDC deposits supported in Phase 1 (ETH staking in Phase 2)

Supported protocols (Phase 1):
  - aave   -- Aave V3 on Base (Pool contract)
  - morpho -- Morpho Blue on Base (MetaMorpho vault)
"""

from __future__ import annotations

from decimal import Decimal, InvalidOperation
from typing import TYPE_CHECKING, Any

import structlog

from ecodiaos.systems.axon.executor import Executor
from ecodiaos.systems.axon.types import (
    ExecutionContext,
    ExecutionResult,
    RateLimit,
    ValidationResult,
)

if TYPE_CHECKING:
    from ecodiaos.clients.wallet import WalletClient

logger = structlog.get_logger()

# -- Constants ---------------------------------------------------------------

# Gas-efficiency floor: deploying less than $20 costs more in gas than the
# yield earned over a reasonable horizon.
MIN_DEPLOYABLE_BALANCE = Decimal("20.00")

# Minimum acceptable APY -- if the protocol reports below this, abort to
# avoid locking capital for negligible returns.
YIELD_FLOOR_APY = Decimal("0.02")

_SUPPORTED_ACTIONS = frozenset({"deposit", "withdraw"})

_SUPPORTED_PROTOCOLS = frozenset({"aave", "morpho"})

# Base mainnet (chain ID 8453) contract addresses
# Aave V3 Pool -- the canonical supply/withdraw entrypoint on Base
_AAVE_V3_POOL_BASE = "0xA238Dd80C259a72e81d7e4664a9801593F98d1c5"

# Morpho Blue MetaMorpho USDC vault on Base
_MORPHO_VAULT_BASE = "0xc1256Ae5FF1cf2719D4937adb3bbCCab2E00A2Ca"

# USDC on Base
_USDC_BASE = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"

_USDC_DECIMALS = 6

# Aave V3 Pool ABI fragments (supply / withdraw)
# supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode)
_AAVE_SUPPLY_SELECTOR = "0x617ba037"
# withdraw(address asset, uint256 amount, address to) returns (uint256)
_AAVE_WITHDRAW_SELECTOR = "0x69328dec"

# ERC-20 approve(address spender, uint256 amount)
_ERC20_APPROVE_SELECTOR = "0x095ea7b3"

# ERC-4626 vault (Morpho MetaMorpho) -- deposit(uint256 assets, address receiver)
_ERC4626_DEPOSIT_SELECTOR = "0x6e553f65"
# ERC-4626 vault -- withdraw(uint256 assets, address receiver, address owner)
_ERC4626_WITHDRAW_SELECTOR = "0xb460af94"

# Error fragments from DeFi interactions
_INSUFFICIENT_FUNDS_PHRASES = (
    "insufficient funds",
    "insufficient balance",
    "exceeds balance",
    "transfer amount exceeds",
    "ERC20: transfer amount exceeds balance",
)


def _is_insufficient_funds(error: str) -> bool:
    lower = error.lower()
    return any(phrase in lower for phrase in _INSUFFICIENT_FUNDS_PHRASES)


def _encode_address(addr: str) -> str:
    """Encode an address as a 32-byte ABI parameter (zero-padded left)."""
    return addr.lower().replace("0x", "").zfill(64)


def _encode_uint256(value: int) -> str:
    """Encode a uint256 as a 32-byte ABI parameter."""
    return hex(value)[2:].zfill(64)


def _encode_uint16(value: int) -> str:
    """Encode a uint16 as a 32-byte ABI parameter (zero-padded left)."""
    return hex(value)[2:].zfill(64)


def _build_approve_calldata(spender: str, amount: int) -> str:
    """Build ERC-20 approve(spender, amount) calldata."""
    return (
        _ERC20_APPROVE_SELECTOR
        + _encode_address(spender)
        + _encode_uint256(amount)
    )


def _build_aave_supply_calldata(
    asset: str, amount: int, on_behalf_of: str, referral_code: int = 0,
) -> str:
    """Build Aave V3 Pool.supply(asset, amount, onBehalfOf, referralCode)."""
    return (
        _AAVE_SUPPLY_SELECTOR
        + _encode_address(asset)
        + _encode_uint256(amount)
        + _encode_address(on_behalf_of)
        + _encode_uint16(referral_code)
    )


def _build_aave_withdraw_calldata(
    asset: str, amount: int, to: str,
) -> str:
    """Build Aave V3 Pool.withdraw(asset, amount, to)."""
    return (
        _AAVE_WITHDRAW_SELECTOR
        + _encode_address(asset)
        + _encode_uint256(amount)
        + _encode_address(to)
    )


def _build_erc4626_deposit_calldata(assets: int, receiver: str) -> str:
    """Build ERC-4626 deposit(assets, receiver)."""
    return (
        _ERC4626_DEPOSIT_SELECTOR
        + _encode_uint256(assets)
        + _encode_address(receiver)
    )


def _build_erc4626_withdraw_calldata(
    assets: int, receiver: str, owner: str,
) -> str:
    """Build ERC-4626 withdraw(assets, receiver, owner)."""
    return (
        _ERC4626_WITHDRAW_SELECTOR
        + _encode_uint256(assets)
        + _encode_address(receiver)
        + _encode_address(owner)
    )


# -- DeFiYieldExecutor -------------------------------------------------------


class DeFiYieldExecutor(Executor):
    """
    Deploy or withdraw idle USDC into yield-bearing DeFi protocols on Base.

    Phase 16c -- Resting Metabolism.  The organism earns yield on idle capital
    during consolidation cycles, preventing cash drag.

    Required params:
      action   (str): "deposit" or "withdraw".
      amount   (str): Human-readable USDC amount, e.g. "50.00" or "1000".
      protocol (str): "aave" or "morpho" (case-insensitive).

    Returns ExecutionResult with:
      data:
        tx_hash        -- on-chain transaction hash
        action         -- "deposit" or "withdraw"
        protocol       -- normalised protocol name
        amount         -- amount as submitted
        amount_raw     -- raw integer amount (USDC smallest unit)
        contract       -- protocol contract address interacted with
        network        -- EVM network ("base")
      side_effects:
        -- Human-readable description for world-state log
      new_observations:
        -- Observation fed back into the workspace for Atune scoring

    Abort conditions (returned as ExecutionResult(success=False)):
      - Balance < MIN_DEPLOYABLE_BALANCE ($20) on deposit
      - WalletClient not injected
      - Param validation failures
      - Insufficient funds on-chain
      - Any protocol / network error
    """

    action_type = "defi_yield"
    description = (
        "Deploy or withdraw idle USDC into DeFi yield protocols (Aave/Morpho) "
        "on Base L2 -- resting metabolism for idle capital (Level 3)"
    )

    required_autonomy = 3       # SOVEREIGN -- deploys real capital on-chain
    reversible = False          # On-chain interactions cannot be reversed
    max_duration_ms = 90_000    # DeFi txs may need approval + supply in sequence
    rate_limit = RateLimit.per_hour(4)

    def __init__(self, wallet: WalletClient | None = None) -> None:
        self._wallet = wallet
        self._logger = logger.bind(system="axon.executor.defi_yield")

    # -- Validation ----------------------------------------------------------

    async def validate_params(self, params: dict[str, Any]) -> ValidationResult:
        """Fast param validation -- no I/O."""
        # action
        action = str(params.get("action", "")).strip().lower()
        if not action:
            return ValidationResult.fail(
                "action is required ('deposit' or 'withdraw')",
                action="missing",
            )
        if action not in _SUPPORTED_ACTIONS:
            return ValidationResult.fail(
                f"action must be one of: {', '.join(sorted(_SUPPORTED_ACTIONS))}",
                action="unsupported value",
            )

        # amount
        amount_raw = str(params.get("amount", "")).strip()
        if not amount_raw:
            return ValidationResult.fail("amount is required", amount="missing")
        try:
            amount_decimal = Decimal(amount_raw)
        except InvalidOperation:
            return ValidationResult.fail(
                "amount must be a valid decimal number (e.g. '50.00')",
                amount="not a decimal",
            )
        if amount_decimal <= Decimal(0):
            return ValidationResult.fail(
                "amount must be greater than zero",
                amount="must be positive",
            )

        # protocol
        protocol = str(params.get("protocol", "")).strip().lower()
        if not protocol:
            return ValidationResult.fail(
                "protocol is required ('aave' or 'morpho')",
                protocol="missing",
            )
        if protocol not in _SUPPORTED_PROTOCOLS:
            return ValidationResult.fail(
                f"protocol must be one of: {', '.join(sorted(_SUPPORTED_PROTOCOLS))}",
                protocol="unsupported value",
            )

        return ValidationResult.ok()

    # -- Execution -----------------------------------------------------------

    async def execute(
        self,
        params: dict[str, Any],
        context: ExecutionContext,
    ) -> ExecutionResult:
        """Execute the DeFi yield operation. Never raises."""
        if self._wallet is None:
            return ExecutionResult(
                success=False,
                error=(
                    "WalletClient not configured. "
                    "Pass wallet= to DeFiYieldExecutor or register via AxonService."
                ),
            )

        action = str(params["action"]).strip().lower()
        amount_str = str(params["amount"]).strip()
        amount_decimal = Decimal(amount_str)
        protocol = str(params["protocol"]).strip().lower()

        self._logger.info(
            "defi_yield_execute",
            action=action,
            amount=amount_str,
            protocol=protocol,
            execution_id=context.execution_id,
        )

        # -- Gate: minimum deployable balance for deposits -------------------
        if action == "deposit" and amount_decimal < MIN_DEPLOYABLE_BALANCE:
            self._logger.info(
                "defi_yield_below_floor",
                amount=amount_str,
                floor=str(MIN_DEPLOYABLE_BALANCE),
                execution_id=context.execution_id,
            )
            return ExecutionResult(
                success=False,
                error=(
                    f"BELOW_GAS_FLOOR: deposit amount ${amount_str} is below the "
                    f"minimum deployable balance of ${MIN_DEPLOYABLE_BALANCE}. "
                    f"Gas costs would exceed yield earned. Aborting to preserve capital."
                ),
                data={
                    "failure_type": "below_gas_floor",
                    "amount": amount_str,
                    "min_deployable": str(MIN_DEPLOYABLE_BALANCE),
                },
            )

        # -- Convert to raw USDC amount (6 decimals) ------------------------
        amount_raw_int = int(amount_decimal * (10 ** _USDC_DECIMALS))

        try:
            if protocol == "aave":
                tx_hash = await self._execute_aave(action, amount_raw_int, context)
                contract = _AAVE_V3_POOL_BASE
            else:
                tx_hash = await self._execute_morpho(action, amount_raw_int, context)
                contract = _MORPHO_VAULT_BASE
        except Exception as exc:
            return self._handle_execution_error(exc, action, amount_str, protocol, context)

        # -- Success ---------------------------------------------------------
        network = self._wallet.network

        self._logger.info(
            "defi_yield_confirmed",
            tx_hash=tx_hash,
            action=action,
            protocol=protocol,
            amount=amount_str,
            network=network,
            execution_id=context.execution_id,
        )

        verb = "Deposited" if action == "deposit" else "Withdrew"
        preposition = "into" if action == "deposit" else "from"

        side_effect = (
            f"{verb} {amount_str} USDC {preposition} {protocol.capitalize()} "
            f"on {network} -- tx: {tx_hash}"
        )

        observation = (
            f"DeFi yield {action}: {amount_str} USDC {preposition} "
            f"{protocol.capitalize()} (tx: {tx_hash[:20]}..., network: {network})"
        )

        return ExecutionResult(
            success=True,
            data={
                "tx_hash": tx_hash,
                "action": action,
                "protocol": protocol,
                "amount": amount_str,
                "amount_raw": amount_raw_int,
                "contract": contract,
                "network": network,
            },
            side_effects=[side_effect],
            new_observations=[observation],
        )

    # -- Protocol-specific execution -----------------------------------------

    async def _execute_aave(
        self,
        action: str,
        amount_raw: int,
        context: ExecutionContext,
    ) -> str:
        """Execute Aave V3 supply or withdraw. Returns tx_hash."""
        wallet = self._wallet
        assert wallet is not None  # Guarded in execute()

        account = wallet._require_account()
        cdp = wallet._require_cdp()
        network = wallet.network
        owner_address = wallet.address

        if action == "deposit":
            # Step 1: Approve Aave Pool to spend USDC
            approve_data = _build_approve_calldata(_AAVE_V3_POOL_BASE, amount_raw)

            self._logger.debug(
                "defi_yield_aave_approve",
                spender=_AAVE_V3_POOL_BASE,
                amount_raw=amount_raw,
                execution_id=context.execution_id,
            )

            await self._send_tx(
                cdp, account, network, _USDC_BASE, approve_data,
            )

            # Step 2: Supply USDC to Aave
            supply_data = _build_aave_supply_calldata(
                _USDC_BASE, amount_raw, owner_address,
            )

            self._logger.debug(
                "defi_yield_aave_supply",
                amount_raw=amount_raw,
                execution_id=context.execution_id,
            )

            tx_hash = await self._send_tx(
                cdp, account, network, _AAVE_V3_POOL_BASE, supply_data,
            )
        else:
            # Withdraw from Aave
            withdraw_data = _build_aave_withdraw_calldata(
                _USDC_BASE, amount_raw, owner_address,
            )

            self._logger.debug(
                "defi_yield_aave_withdraw",
                amount_raw=amount_raw,
                execution_id=context.execution_id,
            )

            tx_hash = await self._send_tx(
                cdp, account, network, _AAVE_V3_POOL_BASE, withdraw_data,
            )

        return tx_hash

    async def _execute_morpho(
        self,
        action: str,
        amount_raw: int,
        context: ExecutionContext,
    ) -> str:
        """Execute Morpho MetaMorpho vault deposit or withdraw. Returns tx_hash."""
        wallet = self._wallet
        assert wallet is not None

        account = wallet._require_account()
        cdp = wallet._require_cdp()
        network = wallet.network
        owner_address = wallet.address

        if action == "deposit":
            # Step 1: Approve vault to spend USDC
            approve_data = _build_approve_calldata(_MORPHO_VAULT_BASE, amount_raw)

            self._logger.debug(
                "defi_yield_morpho_approve",
                spender=_MORPHO_VAULT_BASE,
                amount_raw=amount_raw,
                execution_id=context.execution_id,
            )

            await self._send_tx(
                cdp, account, network, _USDC_BASE, approve_data,
            )

            # Step 2: Deposit into ERC-4626 vault
            deposit_data = _build_erc4626_deposit_calldata(amount_raw, owner_address)

            self._logger.debug(
                "defi_yield_morpho_deposit",
                amount_raw=amount_raw,
                execution_id=context.execution_id,
            )

            tx_hash = await self._send_tx(
                cdp, account, network, _MORPHO_VAULT_BASE, deposit_data,
            )
        else:
            # Withdraw from ERC-4626 vault
            withdraw_data = _build_erc4626_withdraw_calldata(
                amount_raw, owner_address, owner_address,
            )

            self._logger.debug(
                "defi_yield_morpho_withdraw",
                amount_raw=amount_raw,
                execution_id=context.execution_id,
            )

            tx_hash = await self._send_tx(
                cdp, account, network, _MORPHO_VAULT_BASE, withdraw_data,
            )

        return tx_hash

    # -- Transaction helpers -------------------------------------------------

    @staticmethod
    async def _send_tx(
        cdp: Any,
        account: Any,
        network: str,
        to: str,
        data: str,
    ) -> str:
        """Send a transaction via the CDP SDK. Returns the tx hash as a string."""
        from cdp.evm_transaction_types import TransactionRequestEIP1559

        tx_hash = await cdp.evm.send_transaction(
            address=account.address,
            transaction=TransactionRequestEIP1559(
                to=to,
                value=0,
                data=data,
            ),
            network=network,
        )
        return str(tx_hash)

    # -- Error handling ------------------------------------------------------

    def _handle_execution_error(
        self,
        exc: Exception,
        action: str,
        amount_str: str,
        protocol: str,
        context: ExecutionContext,
    ) -> ExecutionResult:
        """Map exceptions to structured ExecutionResult failures."""
        error_str = str(exc)

        if _is_insufficient_funds(error_str):
            self._logger.warning(
                "defi_yield_insufficient_funds",
                action=action,
                protocol=protocol,
                amount=amount_str,
                execution_id=context.execution_id,
            )
            return ExecutionResult(
                success=False,
                error=(
                    f"INSUFFICIENT_FUNDS: wallet does not have enough USDC "
                    f"to {action} {amount_str} via {protocol.capitalize()}."
                ),
                data={
                    "failure_type": "insufficient_funds",
                    "action": action,
                    "protocol": protocol,
                    "amount": amount_str,
                },
            )

        self._logger.error(
            "defi_yield_failed",
            action=action,
            protocol=protocol,
            amount=amount_str,
            execution_id=context.execution_id,
            error=error_str,
        )
        return ExecutionResult(
            success=False,
            error=f"DeFi {action} failed on {protocol.capitalize()}: {error_str}",
            data={
                "failure_type": "protocol_error",
                "action": action,
                "protocol": protocol,
                "amount": amount_str,
            },
        )
