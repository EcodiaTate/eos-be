"""
EcodiaOS — Axon Execution Pipeline

The pipeline is the core of Axon — it takes an approved Intent and executes it.

Pipeline stages:
  1. Budget check — verify the per-cycle execution budget allows another action
  2. Validation — validate parameters for all steps against their executors
  3. Rate limit check — verify each executor is within its rate limit
  4. Circuit breaker check — verify no executor has a tripped circuit
  5. Context assembly — gather credentials, build ExecutionContext
  6. Step execution — execute each step with timeout, progress tracking, and rollback
  7. Outcome assembly — collect results, compute success/partial/failure
  8. Outcome delivery — async: audit log + deliver to Nova

All stages must complete within the total_timeout_per_cycle_ms budget.
Steps that exceed their per-executor timeout are cancelled and reported as failures.

The pipeline does not second-guess approved Intents. Equor already reviewed them.
If a step fails, the pipeline rolls back reversible steps and reports the failure —
it does not re-evaluate whether the intent was correct.
"""

from __future__ import annotations

import asyncio
import time
from typing import TYPE_CHECKING

import structlog

from ecodiaos.systems.axon.audit import AuditLogger
from ecodiaos.systems.axon.credentials import CredentialStore
from ecodiaos.systems.axon.registry import ExecutorRegistry
from ecodiaos.systems.axon.safety import BudgetTracker, CircuitBreaker, RateLimiter
from ecodiaos.systems.axon.types import (
    AxonOutcome,
    ExecutionContext,
    ExecutionRequest,
    ExecutionResult,
    ExecutionStatus,
    FailureReason,
    RollbackResult,
    StepOutcome,
)

if TYPE_CHECKING:
    from ecodiaos.systems.nova.service import NovaService
    from ecodiaos.systems.nova.types import IntentOutcome

logger = structlog.get_logger()


class ExecutionPipeline:
    """
    The Axon execution pipeline.

    Receives approved ExecutionRequests and runs them through the 7-stage
    execution pipeline, delivering outcomes to Nova asynchronously.
    """

    def __init__(
        self,
        registry: ExecutorRegistry,
        budget: BudgetTracker,
        rate_limiter: RateLimiter,
        circuit_breaker: CircuitBreaker,
        credential_store: CredentialStore,
        audit_logger: AuditLogger,
        instance_id: str = "eos-default",
    ) -> None:
        self._registry = registry
        self._budget = budget
        self._rate_limiter = rate_limiter
        self._circuit_breaker = circuit_breaker
        self._credential_store = credential_store
        self._audit = audit_logger
        self._instance_id = instance_id
        self._logger = logger.bind(system="axon.pipeline")
        self._nova: "NovaService | None" = None
        self._atune = None  # AtuneService — for feeding outcomes as percepts

    def set_nova(self, nova: "NovaService") -> None:
        self._nova = nova

    def set_atune(self, atune) -> None:
        self._atune = atune

    async def execute(self, request: ExecutionRequest) -> AxonOutcome:
        """
        Execute an approved Intent through all pipeline stages.

        Returns an AxonOutcome regardless of whether execution succeeded —
        failures are reported, not raised.
        """
        intent = request.intent
        start_time = time.monotonic()

        from ecodiaos.primitives.common import new_id
        execution_id = new_id()

        self._logger.info(
            "pipeline_start",
            execution_id=execution_id,
            intent_id=intent.id,
            goal=intent.goal.description[:60],
            steps=len(intent.plan.steps),
        )

        # ── STAGE 1: Budget check ──────────────────────────────────
        allowed, reason = self._budget.can_execute()
        if not allowed:
            return self._fast_fail(
                intent_id=intent.id,
                execution_id=execution_id,
                status=ExecutionStatus.RATE_LIMITED,
                failure_reason=FailureReason.BUDGET_EXCEEDED.value,
                error=reason,
                start_time=start_time,
            )

        # ── STAGE 2: Validation ───────────────────────────────────
        for step in intent.plan.steps:
            executor = self._registry.get(step.executor)
            if executor is None:
                return self._fast_fail(
                    intent_id=intent.id,
                    execution_id=execution_id,
                    status=ExecutionStatus.FAILURE,
                    failure_reason=FailureReason.UNKNOWN_ACTION_TYPE.value,
                    error=f"No executor registered for '{step.executor}'",
                    start_time=start_time,
                )

            validation = await executor.validate_params(step.parameters)
            if not validation.valid:
                return self._fast_fail(
                    intent_id=intent.id,
                    execution_id=execution_id,
                    status=ExecutionStatus.FAILURE,
                    failure_reason=FailureReason.VALIDATION_ERROR.value,
                    error=f"Step '{step.executor}' validation failed: {validation.reason}",
                    start_time=start_time,
                )

            # Autonomy check
            if executor.required_autonomy > intent.autonomy_level_granted:
                return self._fast_fail(
                    intent_id=intent.id,
                    execution_id=execution_id,
                    status=ExecutionStatus.FAILURE,
                    failure_reason=FailureReason.INSUFFICIENT_AUTONOMY.value,
                    error=(
                        f"Executor '{step.executor}' requires autonomy level "
                        f"{executor.required_autonomy}, but intent has "
                        f"{intent.autonomy_level_granted}"
                    ),
                    start_time=start_time,
                )

        # ── STAGE 3: Rate limit check ─────────────────────────────
        for step in intent.plan.steps:
            executor = self._registry.get(step.executor)
            if executor and not self._rate_limiter.check(
                executor.action_type, executor.rate_limit
            ):
                return self._fast_fail(
                    intent_id=intent.id,
                    execution_id=execution_id,
                    status=ExecutionStatus.RATE_LIMITED,
                    failure_reason=FailureReason.RATE_LIMITED.value,
                    error=f"Rate limit exceeded for executor '{step.executor}'",
                    start_time=start_time,
                )

        # ── STAGE 4: Circuit breaker check ───────────────────────
        for step in intent.plan.steps:
            executor = self._registry.get(step.executor)
            if executor and not self._circuit_breaker.can_execute(executor.action_type):
                return self._fast_fail(
                    intent_id=intent.id,
                    execution_id=execution_id,
                    status=ExecutionStatus.CIRCUIT_OPEN,
                    failure_reason=FailureReason.CIRCUIT_OPEN.value,
                    error=f"Circuit breaker open for executor '{step.executor}'",
                    start_time=start_time,
                )

        # ── STAGE 5: Context assembly ─────────────────────────────
        from ecodiaos.primitives.affect import AffectState
        credentials = await self._credential_store.get_for_intent(intent)
        context = ExecutionContext(
            execution_id=execution_id,
            intent=intent,
            equor_check=request.equor_check,
            credentials=credentials,
            instance_id=self._instance_id,
        )

        # ── STAGE 6: Step execution ───────────────────────────────
        self._budget.begin_execution()
        step_outcomes: list[StepOutcome] = []

        try:
            for i, step in enumerate(intent.plan.steps):
                executor = self._registry.get(step.executor)
                if executor is None:
                    # Should not reach here after validation, but guard anyway
                    continue

                # Calculate remaining time budget for this step
                elapsed_ms = int((time.monotonic() - start_time) * 1000)
                remaining_ms = request.timeout_ms - elapsed_ms

                # Early-break: if we've exhausted the total budget, skip
                # remaining steps rather than running them with a trivial
                # timeout that will almost certainly fail.
                if remaining_ms <= 0:
                    self._logger.warning(
                        "pipeline_budget_exhausted_skipping_remaining",
                        execution_id=execution_id,
                        step_index=i,
                        elapsed_ms=elapsed_ms,
                        budget_ms=request.timeout_ms,
                        steps_remaining=len(intent.plan.steps) - i,
                    )
                    step_outcomes.append(StepOutcome(
                        step_index=i,
                        action_type=executor.action_type,
                        description=step.parameters.get("description", step.executor),
                        result=ExecutionResult(
                            success=False,
                            error=f"Skipped: total budget ({request.timeout_ms}ms) exhausted",
                        ),
                        duration_ms=0,
                    ))
                    break

                step_timeout_ms = min(
                    step.timeout_ms * 3,       # 3x expected as safety margin
                    executor.max_duration_ms,
                    remaining_ms,
                )
                step_timeout_ms = max(step_timeout_ms, 100)  # Minimum 100ms

                step_start = time.monotonic()
                result = await _run_step_with_timeout(
                    executor=executor,
                    params=step.parameters,
                    context=context,
                    timeout_ms=step_timeout_ms,
                )
                step_duration_ms = int((time.monotonic() - step_start) * 1000)

                # Record rate limit usage (only after successful check above)
                self._rate_limiter.record(executor.action_type)

                # Update circuit breaker
                self._circuit_breaker.record_result(executor.action_type, result.success)

                step_outcome = StepOutcome(
                    step_index=i,
                    action_type=executor.action_type,
                    description=step.parameters.get("description", step.executor),
                    result=result,
                    duration_ms=step_duration_ms,
                )
                step_outcomes.append(step_outcome)

                self._logger.debug(
                    "step_complete",
                    execution_id=execution_id,
                    step_index=i,
                    action_type=executor.action_type,
                    success=result.success,
                    duration_ms=step_duration_ms,
                )

                # On failure: decide whether to continue or abort with rollback
                if not result.success:
                    if step.parameters.get("continue_on_failure", False):
                        continue
                    else:
                        # Rollback completed steps
                        rollback_results = await _rollback_completed(
                            step_outcomes=step_outcomes[:-1],  # Exclude the failed step
                            registry=self._registry,
                            context=context,
                        )
                        self._logger.warning(
                            "pipeline_step_failed_rolling_back",
                            execution_id=execution_id,
                            step_index=i,
                            error=result.error[:100],
                            rollback_results=len(rollback_results),
                        )
                        break

        finally:
            self._budget.end_execution()

        # ── STAGE 7: Outcome assembly ─────────────────────────────
        total_duration_ms = int((time.monotonic() - start_time) * 1000)
        all_succeeded = bool(step_outcomes) and all(
            s.result.success for s in step_outcomes
        )
        any_succeeded = any(s.result.success for s in step_outcomes)
        partial = any_succeeded and not all_succeeded

        outcome = AxonOutcome(
            intent_id=intent.id,
            execution_id=execution_id,
            success=all_succeeded,
            partial=partial,
            status=ExecutionStatus.SUCCESS if all_succeeded else (
                ExecutionStatus.PARTIAL if partial else ExecutionStatus.FAILURE
            ),
            step_outcomes=step_outcomes,
            duration_ms=total_duration_ms,
        )
        outcome.world_state_changes = outcome.collect_world_changes()
        outcome.new_observations = outcome.collect_new_observations()
        if not all_succeeded:
            outcome.failure_reason = outcome.classify_failure()

        self._logger.info(
            "pipeline_complete",
            execution_id=execution_id,
            intent_id=intent.id,
            success=all_succeeded,
            partial=partial,
            steps_completed=len(step_outcomes),
            duration_ms=total_duration_ms,
        )

        # ── STAGE 8: Audit + Nova delivery (concurrent) ───────────
        await asyncio.gather(
            self._audit.log(outcome, context),
            self._deliver_to_nova(outcome),
            self._contribute_to_atune(outcome),
            return_exceptions=True,
        )

        return outcome

    async def _deliver_to_nova(self, outcome: AxonOutcome) -> None:
        """
        Deliver the execution outcome to Nova for belief updating.
        Convert AxonOutcome → IntentOutcome (Nova's shared primitive).

        Retries up to 3 times with exponential backoff. If Nova's belief state
        diverges from real execution, goals become stale and learning breaks.
        """
        if self._nova is None:
            return

        from ecodiaos.systems.nova.types import IntentOutcome

        nova_outcome = IntentOutcome(
            intent_id=outcome.intent_id,
            success=outcome.success,
            episode_id=outcome.episode_id,
            failure_reason=outcome.failure_reason,
            new_observations=outcome.new_observations,
        )

        last_error: Exception | None = None
        for attempt in range(3):
            try:
                await self._nova.process_outcome(nova_outcome)
                return  # Success
            except Exception as exc:
                last_error = exc
                if attempt < 2:
                    await asyncio.sleep(0.1 * (2 ** attempt))  # 100ms, 200ms

        self._logger.error(
            "nova_delivery_failed_after_retries",
            intent_id=outcome.intent_id,
            execution_id=outcome.execution_id,
            attempts=3,
            error=str(last_error),
        )

    async def _contribute_to_atune(self, outcome: AxonOutcome) -> None:
        """
        Feed the execution outcome into Atune's workspace as a self-perception.

        The organism perceives its own actions: successes are routine (low salience),
        failures are salient and demand attention.
        """
        if self._atune is None:
            return

        from ecodiaos.systems.atune.types import WorkspaceContribution

        if outcome.success:
            content = (
                f"Action completed: {outcome.execution_id} "
                f"({len(outcome.step_outcomes)} steps)"
            )
            priority = 0.25  # Routine — success is expected
        else:
            content = (
                f"Action failed: {outcome.execution_id} — "
                f"{outcome.failure_reason or 'unknown'}"
            )
            priority = 0.55  # Failure is salient and demands attention

        try:
            self._atune.contribute(WorkspaceContribution(
                system="axon",
                content=content,
                priority=priority,
                reason="action_outcome",
            ))
        except Exception as exc:
            self._logger.debug("atune_contribution_failed", error=str(exc))

    def _fast_fail(
        self,
        intent_id: str,
        execution_id: str,
        status: ExecutionStatus,
        failure_reason: str,
        error: str,
        start_time: float,
    ) -> AxonOutcome:
        """Create a fast-fail outcome without executing any steps."""
        duration_ms = int((time.monotonic() - start_time) * 1000)
        self._logger.warning(
            "pipeline_fast_fail",
            intent_id=intent_id,
            execution_id=execution_id,
            status=status.value,
            failure_reason=failure_reason,
            error=error[:100],
        )
        return AxonOutcome(
            intent_id=intent_id,
            execution_id=execution_id,
            success=False,
            status=status,
            failure_reason=failure_reason,
            error=error,
            duration_ms=duration_ms,
        )


# ─── Helpers ──────────────────────────────────────────────────────


async def _run_step_with_timeout(
    executor,
    params: dict,
    context: ExecutionContext,
    timeout_ms: int,
) -> ExecutionResult:
    """Run a single step executor with timeout enforcement."""
    try:
        return await asyncio.wait_for(
            executor.execute(params, context),
            timeout=timeout_ms / 1000,
        )
    except asyncio.TimeoutError:
        return ExecutionResult(
            success=False,
            error=f"Step timed out after {timeout_ms}ms",
        )
    except Exception as exc:
        return ExecutionResult(
            success=False,
            error=f"Step raised exception: {type(exc).__name__}: {exc}",
        )


async def _rollback_completed(
    step_outcomes: list[StepOutcome],
    registry: ExecutorRegistry,
    context: ExecutionContext,
) -> list[RollbackResult]:
    """
    Attempt to rollback completed steps in reverse order (most recent first).
    Best-effort — non-reversible steps are reported as not-supported.
    """
    results: list[RollbackResult] = []

    for step_outcome in reversed(step_outcomes):
        if not step_outcome.result.success:
            continue  # Failed steps don't need rollback

        executor = registry.get(step_outcome.action_type)
        if executor is None or not executor.reversible:
            results.append(RollbackResult(
                success=False,
                reason=f"Executor '{step_outcome.action_type}' is not reversible",
            ))
            continue

        try:
            rollback_result = await executor.rollback(
                context.execution_id,
                context,
            )
            results.append(rollback_result)
        except Exception as exc:
            results.append(RollbackResult(
                success=False,
                reason=f"Rollback exception: {exc}",
            ))
            logger.error(
                "rollback_failed",
                step_index=step_outcome.step_index,
                action_type=step_outcome.action_type,
                error=str(exc),
            )

    return results
